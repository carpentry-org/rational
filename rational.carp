(deftype Rational [numerator Int, denominator Int])

(defmodule Math
  (defn gcd [a b]
    (if (= b 0)
      a
      (gcd b (Int.mod a b))))
)

(defmodule Rational
  (defn new [n d]
    (let [g (Math.gcd n d)]
      (Rational.init (/ n g) (/ d g))))

  (defn from-int [i]
    (Rational.init i 1))

  (defn to-int [r]
    (/ @(numerator r) @(denominator r)))

  (defn from-float [f]
    (let-do [t 1
             t2 f]
      (while (/= t2 (Float.from-int (Float.to-int t2)))
        (do
          (set! t (* t 10))
          (set! t2 (* f (Float.from-int t)))))
      (let [fk (Float.to-int (* f (Float.from-int t)))
            k (Math.gcd fk t)]
        (Rational.new (/ fk k) (/ t k)))))

  (defn to-float [r]
    (/ (Float.from-int @(numerator r)) (Float.from-int @(denominator r))))

  (defn + [a b]
    (let [na @(numerator a)
          nb @(numerator b)
          da @(denominator a)
          db @(denominator b)
          n (+ (* na db) (* nb da))
          d (* da db)]
      (Rational.new n d))
  )

  (defn - [a b]
    (let [na @(numerator a)
          nb @(numerator b)
          da @(denominator a)
          db @(denominator b)
          n (- (* na db) (* nb da))
          d (* da db)]
      (Rational.new n d))
  )

  (defn * [a b]
    (let [na @(numerator a)
          nb @(numerator b)
          da @(denominator a)
          db @(denominator b)
          n (* na nb)
          d (* da db)]
      (Rational.new n d))
  )

  (defn / [a b]
    (let [na @(numerator a)
          nb @(numerator b)
          da @(denominator a)
          db @(denominator b)
          n (* na db)
          d (* da nb)]
      (Rational.new n d))
  )

  (defn mod [a b]
    (let [m (Rational./ a b)]
      (Rational.* &(Rational.- a b) &m)))

  (defn = [a b]
    (and (= (numerator a) (numerator b))
         (= (denominator a) (denominator b))))

  (defn hash [r]
    (if (= 1 @(denominator r))
      (hash (numerator r))
      (hash &(to-float r))))

  (defn str [r]
    (fmt "(Rational %d/%d)" @(numerator r) @(denominator r)))
)
